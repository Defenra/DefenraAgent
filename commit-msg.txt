perf: fix memory leaks, goroutine leaks and optimize for high-load edge scenarios

Critical fixes for Edge Agents handling tens of thousands of connections:

1. **TLS Fingerprint Memory Leak (HIGH)**
   - Problem: Global tlsFingerprints map grew unbounded, never cleaned
   - Under sustained attack (1000 req/sec) → millions of entries → OOM
   - Solution: Added tlsFingerprintEntry with timestamp + automatic cleanup every 5 min
   - Entries older than 30 minutes are removed
   - Logs: "[TLS-Fingerprint] Cleaned up X old entries"

2. **Goroutine Leak in Challenge Response (HIGH)**
   - Problem: sendChallengeResponse created goroutine that could hang forever
   - If client disconnects during slowloris attack → goroutine leaks
   - Solution: Replaced goroutine approach with chunked writes + http.Flusher
   - Writes data in 1KB chunks with Flush() to detect disconnects
   - No goroutines created, bounded by 5-second timeout

3. **UDP Buffer Allocation (MEDIUM)**
   - Problem: handleUDPProxy allocated 65KB buffer for every UDP packet
   - High UDP traffic → excessive GC pressure
   - Solution: Use sync.Pool for buffer reuse
   - Copy data before spawning goroutine to prevent race conditions
   - Reduces allocations from N*65KB to pool size * 65KB

4. **Rate Limit GC Pressure (MEDIUM)**
   - Problem: Cleanup created new slice with append (garbage generation)
   - Solution: Inplace filtering with index tracking
   - Reuses underlying array instead of creating new slice

**Testing:**
- All tests pass: go test ./...
- Build successful: go build ./...
- Code formatted: go fmt ./...

**Impact:**
- Prevents OOM crashes under DDoS attacks
- Reduces goroutine leaks (better stability over days/weeks)
- Lower GC pressure (fewer pauses, better latency)
- Maintains all existing functionality